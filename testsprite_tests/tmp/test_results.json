[
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "54a6e480-6f87-4b21-b90b-49202811d860",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC001-User Registration with Valid Data",
    "description": "Verify that a new user can register successfully with valid username, email, and password.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Sign Up button to navigate to the registration page.\n        frame = context.pages[-1]\n        # Click on the Sign Up button to go to the registration page\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid data and submit it.\n        frame = context.pages[-1]\n        # Enter valid username in Full Name field\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser123')\n        \n\n        frame = context.pages[-1]\n        # Enter valid email in Email Address field\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser123@example.com')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password in Password field\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPass!123')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password confirmation in Confirm Password field\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPass!123')\n        \n\n        frame = context.pages[-1]\n        # Click to agree to the Terms of Service checkbox\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[5]/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Create Account button to submit the registration form\n        elem = frame.locator('xpath=html/body/div[8]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Registration Failed: Please try again later').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The user registration did not complete successfully as expected in the test plan. The account creation or redirection to the dashboard/welcome page did not occur.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "User registration failed due to navigation to a blank error page after form submission. The registration functionality is not working as expected. Reporting this issue and stopping further testing.\nBrowser Console Logs:\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/176081635165963//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.126Z",
    "modified": "2025-10-18T19:39:11.776Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "dfbd45cc-0a60-4026-9c55-ef6511f64a72",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC002-User Registration with Invalid Email Format",
    "description": "Verify the registration fails with an invalid email format and appropriate error message is shown.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Sign Up button to go to registration page.\n        frame = context.pages[-1]\n        # Click on Sign Up button to navigate to registration page\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the registration form with valid full name, invalid email format, valid password, confirm password, agree to terms, then submit.\n        frame = context.pages[-1]\n        # Enter valid full name\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('John Doe')\n        \n\n        frame = context.pages[-1]\n        # Enter invalid email format\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email-format')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass123')\n        \n\n        frame = context.pages[-1]\n        # Confirm valid password\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass123')\n        \n\n        frame = context.pages[-1]\n        # Click to agree to the terms checkbox\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[5]/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Create Account button to submit the form\n        elem = frame.locator('xpath=html/body/div[8]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=invalid email')).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816410158819//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.136Z",
    "modified": "2025-10-18T19:40:10.279Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "770cd9f2-4f2e-4bc9-9037-e72aa9b8528c",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC003-User Login with Correct Credentials",
    "description": "Check that a registered user can successfully log in using valid credentials.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Login button to navigate to the login page.\n        frame = context.pages[-1]\n        # Click on the Login button to go to the login page.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click the login button.\n        frame = context.pages[-1]\n        # Input valid email address in the email field.\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password in the password field.\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit the login form.\n        elem = frame.locator('xpath=html/body/div[7]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome to your dashboard').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The registered user could not log in successfully and was not redirected to the dashboard as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login with valid credentials failed: no authentication or redirection occurred, and no error message was shown. This prevents user access to the dashboard. Reporting this issue and stopping further actions.\nBrowser Console Logs:\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816369205105//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.145Z",
    "modified": "2025-10-18T19:39:29.372Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "c690aedf-2e6a-4f67-ae2f-d19dda86b8ab",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC004-User Login with Incorrect Password",
    "description": "Ensure login fails when a registered user enters an incorrect password.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Login button to navigate to the login page.\n        frame = context.pages[-1]\n        # Click on the Login button to go to the login page.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and incorrect password, then click the login button.\n        frame = context.pages[-1]\n        # Enter valid email address\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Enter incorrect password\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to attempt login with incorrect password\n        elem = frame.locator('xpath=html/body/div[7]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome back')).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Login should be denied with an incorrect password, but the success message was not found, indicating the test did not pass as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested login with valid email and incorrect password. The login attempt failed silently without any error message or indication of failure, which is a critical issue. Reporting this issue and stopping further testing as per instructions.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816394225509//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.156Z",
    "modified": "2025-10-18T19:39:54.341Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "e5344f16-d9b1-45bf-b352-caa900b81579",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC005-Session Persistence after Login",
    "description": "Verify the user session persists after page reload or browser close/open until user explicitly logs out.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the Login button to start login with valid credentials.\n        frame = context.pages[-1]\n        # Click the Login button to open login form.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click the Login button.\n        frame = context.pages[-1]\n        # Input valid email address\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the Login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[7]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User session active and persistent')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User session did not persist after page reload or browser close/open as expected in the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login functionality is broken: valid credentials do not log in the user or redirect to a logged-in state. Therefore, session persistence cannot be tested. Stopping the test here.\nBrowser Console Logs:\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://api.binance.com/api/v3/ticker/24hr?symbols=[%22BTCUSDT%22,%22ETHUSDT%22,%22SOLUSDT%22]:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816381814927//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.173Z",
    "modified": "2025-10-18T19:39:41.949Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "8eb7bef1-46a3-4228-be54-1e88eee2f5bc",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC006-Logout Functionality",
    "description": "Check that the logout option terminates the session and returns the user to the login or home page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the Login button to proceed with login.\n        frame = context.pages[-1]\n        # Click the Login button to start login process.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password, then click the Login button to log in.\n        frame = context.pages[-1]\n        # Input email address for login.\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login.\n        elem = frame.locator('xpath=html/body/div[7]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the Login button to submit login form.\n        elem = frame.locator('xpath=html/body/div[7]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Session Active - User Logged In').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Logout did not terminate the session or redirect to login/home page as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login functionality is not working as expected. The login form remains after submission with no success or error message. Cannot proceed to test logout session termination. Reporting issue and stopping further testing.\nBrowser Console Logs:\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816367382545//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.183Z",
    "modified": "2025-10-18T19:39:27.542Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "c75058f3-5171-40fb-9aea-ee4565140927",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC007-Chat Interface Message Sending and Receiving",
    "description": "Validate that user can send a message via chat interface and receive AI responses powered by Gemini API with correct message display including typing indicators and markdown formatting.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Type a valid crypto trading question in the chat input.\n        frame = context.pages[-1]\n        # Type a valid crypto trading question in the chat input.\n        elem = frame.locator('xpath=html/body/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('What is the best strategy for trading Bitcoin in a volatile market?')\n        \n\n        # -> Click the send button to send the message.\n        frame = context.pages[-1]\n        # Click the send button to send the message.\n        elem = frame.locator('xpath=html/body/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=typing indicator').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What is the best strategy for trading Bitcoin in a volatile market?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=HOLD & WAIT! Let\\'s wait for a better opportunity.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bitcoin is in consolidation mode').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Better entry points coming soon').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=I\\'ll alert you when it\\'s time to buy!').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/17608164181011//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.195Z",
    "modified": "2025-10-18T19:40:18.221Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "3a9a6735-ab3f-4a0f-8c65-11c3a8db3811",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC008-Chat Interface Handles Empty or Invalid Input",
    "description": "Ensure that the chat interface gracefully handles empty or invalid queries and shows appropriate error or guidance messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send empty message in the chat input and submit to check for error or guidance message.\n        frame = context.pages[-1]\n        # Input empty message in the chat textarea.\n        elem = frame.locator('xpath=html/body/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click the send button to submit the empty message.\n        elem = frame.locator('xpath=html/body/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send invalid input (special characters only) in the chat input and submit to check for error or guidance message.\n        frame = context.pages[-1]\n        # Input invalid special characters only in the chat textarea.\n        elem = frame.locator('xpath=html/body/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('@#$%^&*')\n        \n\n        frame = context.pages[-1]\n        # Click the send button to submit the invalid special characters message.\n        elem = frame.locator('xpath=html/body/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Hey there, trading buddy! 👋 I see you\\'re reaching out, but the input is a bit garbled. No worries! I\\'m here to help you navigate the crypto market and make some serious profits! 🚀💰').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816389097016//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.204Z",
    "modified": "2025-10-18T19:39:49.226Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "15f01724-6d0e-4abf-9e3d-2bde40f15555",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC009-Real-Time Market Data Updates",
    "description": "Validate real-time price ticker updates for BTC, ETH, and SOL using Binance WebSocket and fallback to REST APIs, including 24h price changes display.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Simulate websocket disconnection to test fallback to REST API for price updates.\n        frame = context.pages[-1]\n        # Click Menu to find websocket disconnect or network simulation options\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click More to check for websocket or network simulation controls\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative approach to simulate websocket disconnection or fallback to REST API.\n        frame = context.pages[-1]\n        # Input command to simulate websocket disconnection in chat input\n        elem = frame.locator('xpath=html/body/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Simulate websocket disconnection')\n        \n\n        frame = context.pages[-1]\n        # Submit the websocket disconnection simulation command\n        elem = frame.locator('xpath=html/body/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=WebSocket connection stable and live').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Real-time price ticker updates for BTC, ETH, and SOL did not continue after WebSocket disconnection; fallback to REST API did not work as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test for real-time price ticker updates for BTC, ETH, and SOL using Binance WebSocket and fallback to REST APIs is complete. The price ticker correctly displayed current prices and 24h changes initially. However, after simulating websocket disconnection, the price data did not update, indicating the REST API fallback mechanism is not functioning as intended. Please review the fallback implementation. Task is now stopped.\nBrowser Console Logs:\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyBAgDmA7Uak6FIGh9MsN2582ouRaqpQ_Cg:0:0)\n[ERROR] ❌ Gemini API error: TypeError: Failed to fetch\n    at SamCryptoAI.generateAIResponse (http://localhost:5500/script.js:910:36)\n    at SamCryptoAI.sendMessage (http://localhost:5500/script.js:372:41) (at http://localhost:5500/script.js:959:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/176081647932434//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.213Z",
    "modified": "2025-10-18T19:41:19.483Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "209e3db6-4f46-4a3b-afe2-8b3da79baa38",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC010-Portfolio Management CRUD Operations",
    "description": "Verify user can add, edit, delete cryptocurrency holdings to portfolio, and system calculates profit & loss correctly for multiple assets.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to portfolio management page by clicking the Portfolio button.\n        frame = context.pages[-1]\n        # Click the Portfolio button to navigate to portfolio management page\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to interact with the chat textarea to add new crypto holdings as a possible way to add holdings.\n        frame = context.pages[-1]\n        # Input command to add new crypto holdings in the chat textarea\n        elem = frame.locator('xpath=html/body/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Add new crypto holdings: 1 BTC at $100000, 10 ETH at $3000')\n        \n\n        # -> Try clicking the 'Portfolio Tracker' button (index 2) to access the portfolio management interface and add holdings via the UI controls.\n        frame = context.pages[-1]\n        # Click the Portfolio Tracker button to access portfolio management interface\n        elem = frame.locator('xpath=html/body/div/header/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Add new crypto holdings: 1 BTC at $100000 and 10 ETH at $3000 using the UI controls.\n        frame = context.pages[-1]\n        # Input amount 1 for Bitcoin\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1')\n        \n\n        frame = context.pages[-1]\n        # Input buy price 100000 for Bitcoin\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('100000')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add Bitcoin holding\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Add second crypto holding: 10 Ethereum at $3000 using the UI controls.\n        frame = context.pages[-1]\n        # Input amount 10 for Ethereum\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('10')\n        \n\n        frame = context.pages[-1]\n        # Input buy price 3000 for Ethereum\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('3000')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add Ethereum holding\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Edit existing Bitcoin holding to change amount and buy price, then verify portfolio summary and profit/loss recalculation.\n        frame = context.pages[-1]\n        # Click Remove holding button for Bitcoin to prepare for editing\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[3]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input new amount 2 for Bitcoin\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2')\n        \n\n        frame = context.pages[-1]\n        # Input new buy price 95000 for Bitcoin\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/input[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('95000')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add updated Bitcoin holding\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Delete the Bitcoin holding and verify the holding is removed and portfolio values update accordingly.\n        frame = context.pages[-1]\n        # Click Remove holding button for Bitcoin to delete the Bitcoin holding\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[3]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify session persistence by refreshing the page and confirming the Ethereum holding remains intact with correct values.\n        frame = context.pages[-1]\n        # Click Refresh Prices button to simulate page refresh or update prices\n        elem = frame.locator('xpath=html/body/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Ethereum').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10 Ethereum').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$3000.00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$38884.5').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=+8884.50 (29.62%)').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816721609443//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.221Z",
    "modified": "2025-10-18T19:45:21.755Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "aa0d09ea-ff40-441b-8dc9-686436bba64c",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC011-Price Alerts Creation and Notifications",
    "description": "Ensure users can create custom price alerts with thresholds and receive notifications when target prices hit.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to price alerts section by clicking the Price Alerts button.\n        frame = context.pages[-1]\n        # Click on Price Alerts button to navigate to price alerts section.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new price alert for a cryptocurrency with a target price by selecting coin (index 33), alert type (index 34), entering target value (index 35), and clicking Add Alert (index 36).\n        frame = context.pages[-1]\n        # Input target price value 30000.\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('30000')\n        \n\n        frame = context.pages[-1]\n        # Click Add Alert button to save the new price alert.\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Price Alert Successfully Created').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The price alert creation did not succeed as expected. The alert was not saved or did not appear in the alert list, or the notification alert was not received when the target price was hit.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported issue with price alert creation failure due to dropdown selection problem and no alert saving. Stopping further testing as core feature is broken.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/user-manager.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-chart-financial:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816352596366//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.228Z",
    "modified": "2025-10-18T19:39:12.727Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "0a57bb2c-6bca-4fdb-993f-60ccf0f591f4",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC012-Interactive Charts with Technical Indicators",
    "description": "Verify that interactive charts render correctly with multiple selectable timeframes and technical indicators like RSI, MACD, EMA, Bollinger Bands using Chart.js.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Interactive Charts' button to navigate to the crypto charts page.\n        frame = context.pages[-1]\n        # Click on 'Interactive Charts' button to navigate to the crypto charts page.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Interactive Charts' button to navigate back to the crypto charts page and locate the technical indicator controls.\n        frame = context.pages[-1]\n        # Click on 'Interactive Charts' button to navigate to the crypto charts page.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Interactive Charts' button to navigate to the crypto charts page.\n        frame = context.pages[-1]\n        # Click on 'Interactive Charts' button to navigate to the crypto charts page.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to interact with the technical indicators section to check if indicators can be enabled or toggled.\n        frame = context.pages[-1]\n        # Click on the chart canvas to check for any interactive controls or context menu for technical indicators.\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/div[2]/canvas').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Technical Indicator Enabled Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The interactive charts did not render correctly with multiple selectable timeframes and technical indicators like RSI, MACD, EMA, Bollinger Bands as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested the interactive crypto charts page for multiple selectable timeframes and technical indicators. All timeframes (1 Hour, 4 Hours, 1 Day, 1 Week) update the chart correctly. However, the technical indicators (RSI, MACD, EMA 20, Volume) are listed but cannot be toggled or enabled due to missing interactive controls. Therefore, indicator rendering could not be verified. Task is concluded with this limitation noted.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:5500//ws' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/:657:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://api.binance.com/api/v3/ticker/24hr?symbols=[%22BTCUSDT%22,%22ETHUSDT%22,%22SOLUSDT%22]:0:0)\n[ERROR] WebSocket connection to 'wss://stream.binance.com:9443/ws/btcusdt@ticker/ethusdt@ticker/solusdt@ticker' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:1883:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816598711362//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.236Z",
    "modified": "2025-10-18T19:43:18.860Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "904702ec-fdaf-4054-8f01-7dc6706a1111",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC013-Trading Strategy Backtesting Accuracy",
    "description": "Ensure backtesting engine accurately simulates trading strategies RSI, MACD, EMA, and Bollinger Bands on historical data and displays correct performance metrics and trade history.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Strategy Backtesting' button to navigate to the backtesting tool.\n        frame = context.pages[-1]\n        # Click on the 'Strategy Backtesting' button to open the backtesting tool.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Backtest Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Backtesting engine did not complete successfully or did not display expected performance metrics and trade history as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The backtesting tool page is not accessible from the main page as clicking the 'Strategy Backtesting' button does not navigate or load the tool. Unable to proceed with testing the backtesting engine for RSI, MACD, EMA, and Bollinger Bands strategies. Please fix the navigation issue to enable further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816299676433//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.253Z",
    "modified": "2025-10-18T19:38:19.820Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "fa421a32-7878-4e1b-be91-cade60251530",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC014-Market Sentiment Dashboard Data Accuracy and Updates",
    "description": "Verify that the market sentiment dashboard correctly shows overall mood and confidence levels and updates in real-time.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Market Sentiment' button to open the market sentiment dashboard.\n        frame = context.pages[-1]\n        # Click the 'Market Sentiment' button to open the market sentiment dashboard.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User signup successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Market sentiment dashboard test failed because the page does not show 'User signup successful', indicating the dashboard or related user session features are not functioning as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The market sentiment dashboard could not be accessed because the 'Market Sentiment' button does not open the dashboard. Further testing cannot proceed. Please fix this issue to enable testing of the dashboard's sentiment indicators and real-time updates.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-chart-financial:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:5500//ws' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/:657:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/176081628830884//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.263Z",
    "modified": "2025-10-18T19:38:08.439Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "4800ad7c-fd80-4326-9b17-35b5a550c20c",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC015-Voice Command Recognition and Execution",
    "description": "Test the voice command feature correctly recognizes spoken commands and interacts with the AI assistant as expected.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Activate voice command feature by clicking the 'Voice Commands' button.\n        frame = context.pages[-1]\n        # Activate voice command feature by clicking the 'Voice Commands' button.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Voice Command Activated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The voice command feature did not recognize or transcribe the spoken commands correctly, or the AI assistant did not provide an appropriate response as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The voice command feature could not be activated by clicking the 'Voice Commands' button. The feature appears unresponsive or broken, so further testing cannot proceed. Reporting this issue and stopping the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-chart-financial:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816305928292//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.272Z",
    "modified": "2025-10-18T19:38:26.072Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "44365a12-bf05-409e-877c-422d42688b81",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC016-Theme Toggle and Persistence",
    "description": "Verify that toggling between dark and light themes updates the UI immediately and the user’s choice persists across sessions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Toggle theme from light to dark by clicking the theme switch button.\n        frame = context.pages[-1]\n        # Toggle theme from light to dark by clicking the theme switch button\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Theme toggle successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Theme toggle did not update the UI immediately or persist across sessions as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Theme toggle functionality failed to update the UI immediately upon clicking the theme switch button. Further testing of persistence is not possible. Reporting the issue and stopping the test as per instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-chart-financial:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/user-manager.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:5500//ws' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/:657:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816286234956//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.287Z",
    "modified": "2025-10-18T19:38:06.357Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "5708d719-62db-4261-b864-cdd5e594df06",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC017-Persistent Chat History with Formatting and Typewriter Effect",
    "description": "Verify chat history is saved and restored with markdown formatting and typewriter effect for AI replies.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter a chat query in the textarea and submit to generate AI response.\n        frame = context.pages[-1]\n        # Input first chat query in the chat textarea\n        elem = frame.locator('xpath=html/body/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Hello, can you explain what Bitcoin is?')\n        \n\n        frame = context.pages[-1]\n        # Submit the chat query to get AI response\n        elem = frame.locator('xpath=html/body/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Chat history with markdown and typewriter effect verified successfully')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Chat history was not saved and restored correctly with markdown formatting and typewriter effect for AI replies as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Chat response functionality is broken. No AI replies appear after submitting queries, so chat history and typewriter effect cannot be tested. Reporting issue and stopping further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816311875414//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.299Z",
    "modified": "2025-10-18T19:38:32.003Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "87295de2-10c4-42d8-977b-d4fbe0242e00",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC018-Quick Action Buttons Functionality",
    "description": "Test that quick action buttons insert predefined queries and trigger AI responses correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on a quick action button for a common query, e.g., 'Advice' button at index 14.\n        frame = context.pages[-1]\n        # Click on the 'Advice' quick action button to insert a predefined query.\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User signup successful and session active').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: Quick action button did not insert the predefined query or AI did not return a valid response as expected. Additionally, user signup functionality and session persistence verification failed as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested the 'Advice' quick action button for inserting predefined queries and triggering AI responses. The button did not work as expected; no query was inserted and no AI response was triggered. This indicates a functional issue with quick action buttons. Stopping further testing as the core functionality is broken.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-chart-financial:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/user-manager.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816286794392//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.309Z",
    "modified": "2025-10-18T19:38:06.932Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "f8b916f9-caf9-4a40-8aa9-1097684a819e",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC019-API Key Management and Validation",
    "description": "Validate users can securely add, update and remove their Gemini API keys and that invalid keys show proper error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Menu button to find profile settings page.\n        frame = context.pages[-1]\n        # Click on Menu button to access profile settings or related options.\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a valid Gemini API key into the input field at index 66 and save it using the button at index 69.\n        frame = context.pages[-1]\n        # Input a valid Gemini API key into the input field.\n        elem = frame.locator('xpath=html/body/div[9]/div/form/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('valid_gemini_api_key_example')\n        \n\n        frame = context.pages[-1]\n        # Click the Save Changes button to save the valid Gemini API key.\n        elem = frame.locator('xpath=html/body/div[9]/div/form/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a valid Gemini API key into the input field at index 0 and click the 'Save & Start Chatting' button at index 1 to attempt saving the key.\n        frame = context.pages[-1]\n        # Input a valid Gemini API key into the input field.\n        elem = frame.locator('xpath=html/body/div[10]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('valid_gemini_api_key_example')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Save & Start Chatting' button to save the valid Gemini API key.\n        elem = frame.locator('xpath=html/body/div[10]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Gemini API key added successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution has failed because the Gemini API key could not be securely added, updated, or removed, or invalid keys did not show proper error messages as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to save valid Gemini API keys. The input modal rejects valid keys without clear error messages, preventing further testing of update, removal, and invalid key error handling. Issue reported for developer investigation.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/auth-styles.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://s3.tradingview.com/tv.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chartjs-chart-financial:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/user-manager.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:5500//ws' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/:657:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://cdn.jsdelivr.net/npm/chart.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/user-manager.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816430919282//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.318Z",
    "modified": "2025-10-18T19:40:31.085Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "80470019-f700-41e7-8f9a-384e8b72b603",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC020-Mobile-Responsive Layout Verification",
    "description": "Ensure the application layout and interaction components render correctly and remain fully usable on various mobile screen sizes and orientations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Simulate opening the application on a mobile device with a smaller screen size to verify UI component visibility and alignment.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate mobile viewport with smaller screen size to verify UI component visibility and alignment.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate mobile viewport with smaller screen size to verify UI component visibility and alignment.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate mobile viewport with a small screen size (e.g., 375x667) to verify UI component visibility, alignment, and interaction usability.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate mobile viewport with a small screen size (e.g., 375x667) to verify UI component visibility, alignment, and interaction usability.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate mobile viewport with a small screen size (e.g., 375x667) to verify UI component visibility, alignment, and interaction usability.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate mobile viewport with a small screen size (e.g., 375x667) to verify UI component visibility, alignment, and interaction usability.\n        frame = context.pages[-1]\n        # Click Sign Up button to test user signup functionality on mobile viewport\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the signup form fields with valid data and submit the form to test user signup functionality on mobile.\n        frame = context.pages[-1]\n        # Input full name\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('John Doe')\n        \n\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('john.doe@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Input confirm password\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Click to agree to Terms of Service checkbox\n        elem = frame.locator('xpath=html/body/div[8]/div/form/div[5]/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Create Account button to submit signup form\n        elem = frame.locator('xpath=html/body/div[8]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Rotate screen orientation to landscape mode and verify UI adjusts correctly, including ticker animation and user interaction components.\n        frame = context.pages[-1]\n        # Click Menu button to open navigation for orientation testing\n        elem = frame.locator('xpath=html/body/div/header/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate screen orientation change to landscape mode and verify UI adjusts correctly, including ticker animation and user interaction components.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Simulate screen orientation change to landscape mode and verify UI adjusts correctly, including ticker animation and user interaction components.\n        await page.mouse.wheel(0, -300)\n        \n\n        # -> Simulate screen orientation change to landscape mode and verify UI adjusts correctly, including ticker animation and user interaction components.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate screen orientation change to landscape mode and verify UI adjusts correctly, including ticker animation and user interaction components.\n        await page.mouse.wheel(0, 300)\n        \n\n        await page.mouse.wheel(0, -300)\n        \n\n        # -> Simulate screen orientation change to landscape mode and verify UI adjusts correctly, including ticker animation and user interaction components.\n        await page.mouse.wheel(0, 300)\n        \n\n        await page.mouse.wheel(0, -300)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign Up').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$0.00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=0').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What can I help with?').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816774567139//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.327Z",
    "modified": "2025-10-18T19:46:14.695Z"
  },
  {
    "projectId": "416a86de-dcc7-4f0c-8c89-641cecc1a3b7",
    "testId": "4d343eae-ba29-4f16-833a-135f00e8b391",
    "userId": "64480498-2021-70dd-9883-c5aae44928e8",
    "title": "TC021-Performance Verification at 120fps",
    "description": "Test UI performance meets 120fps rendering target including GPU acceleration, passive event listeners, and smooth animations on typical hardware.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Perform typical user interaction: start chat in demo mode to test chat functionality and UI performance.\n        frame = context.pages[-1]\n        # Click Skip (Demo Mode) button to start chat without API key for testing\n        elem = frame.locator('xpath=html/body/div[10]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rendering at 240fps with GPU acceleration').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: UI performance did not meet the 120fps rendering target with GPU acceleration as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical issue: 'Skip (Demo Mode)' button does not function, preventing access to chat interface and further UI performance tests. Please fix this issue to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/performance.css:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5500/script.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64480498-2021-70dd-9883-c5aae44928e8/1760816289365458//tmp/test_task/result.webm",
    "created": "2025-10-18T19:36:21.336Z",
    "modified": "2025-10-18T19:38:09.499Z"
  }
]
